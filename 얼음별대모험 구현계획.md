# MEETLOG 기능 개선 구현 계획 (v2.0)

## 0. 환경 및 프로젝트 구조

### 0.1 개발 환경 요약
- **OS**: macOS (경로 `/Users/sangwoolee/...` 기반)
- **Shell**: `zsh`
- **주요 런타임**: Java 11 (Maven 빌드, Eclipse Tomcat 9), Python 3.13 (KoBERT API)
- **서버**: 로컬 Tomcat 9 (`MeetLog/Servers/Tomcat v9.0 Server at localhost-config`)
- **프론트엔드**: JSP + JSTL, Tailwind CDN 사용
- **DB**: MariaDB 10.x (`database/master.sql` 스키마 기준, `root:7564@localhost:3306/meetlog`)
- **추가 서비스**: `kobert-api-server` (Python/FastAPI)로 추천 API 제공

### 0.2 주요 디렉터리 구조
```
MEETLOG/
├─ MeetLog/                  # 메인 Java 웹 애플리케이션
│  ├─ pom.xml                # Maven 프로젝트 설정
│  ├─ src/
│  │  ├─ main/java/          # Servlet, Service, DAO, Model 등 Java 소스
│  │  ├─ main/resources/     # MyBatis 매퍼, 설정 파일
│  │  └─ main/webapp/        # JSP, 정적 리소스
│  ├─ target/                # 빌드 산출물
│  └─ Servers/               # 로컬 Tomcat 설정
├─ kobert-api-server/        # 리뷰 벡터화 FastAPI 서버
├─ database/                 # SQL 스키마 & 샘플 데이터
├─ meetlog_uploads/          # 업로드 자산 (이미지 등)
└─ 기타 문서 (README, todo_list, CLAUDE.md 등)
```

#### MeetLog/src/main/java
- `controller/` : Servlet 계층 (예약, 결제, 쿠폰, 마이페이지 등)
- `service/` : 비즈니스 로직 (ReservationService, CouponService, PointService 등)
- `dao/` : MyBatis DAO (`ReservationDAO`, `UserCouponDAO`, `PointDAO` 등)
- `model/` : POJO 도메인 객체 (`Reservation`, `Coupon`, `User`, `Point` 등)
- `dto/`, `adapter/` : 뷰/외부 연동용 DTO 및 어댑터
- `erpController/`, `erpService/`, `erpDto/` : ERP 모듈 관련 서브 패키지
- `util/`, `typehandler/`, `filter/` : 공용 유틸리티, MyBatis 타입 핸들러, 서블릿 필터

#### MeetLog/src/main/resources
- `mappers/` : MyBatis 매퍼 XML (`ReservationMapper.xml`, `CouponMapper.xml`, `UserCouponMapper.xml`, `PointMapper.xml` 등)
- `mybatis-config.xml` : 전역 MyBatis 설정
- `config.properties`, `api.properties`, `db.properties` : 런타임 설정 파일

#### MeetLog/src/main/webapp
- `WEB-INF/views/` : JSP 뷰 (`mypage`, `coupon-management`, `business`, `erp`, `reservation` 등)
- `WEB-INF/web.xml` : 서블릿 매핑
- `css/`, `js/`, `assets/` : 정적 자원

#### 기타
- `kobert-api-server/`
  - `main.py`, `routers/`, `services/`: KoBERT 추천 API (FastAPI + PyTorch)
  - `vectorizer/`: 임베딩 로직, `venv/` 가상환경
- `database/`
  - `master.sql`, `semi-erp.sql` 등 스키마 및 샘플 데이터
  - `archive/`: 과거 덤프
- `meetlog_uploads/`: 업로드된 이미지·파일 저장소

---

## 1. 개요
- **작성 목적**: 쿠폰 기능 고도화 및 신규 포인트 시스템 도입, 텔레그램 알림 연동에 필요한 개발 범위, 선행 작업, 검증 계획을 명확히 하고 실무 투입 가능한 수준의 상세 구현 가이드를 제공한다.
- **작성 기준 소스**: `MeetLog` 모놀리식 웹 애플리케이션 (Java Servlet + JSP, MyBatis)
- **목표**: 각 기능별로 **수정할 파일 목록**, **핵심 코드 스니펫**, **롤백/에러 처리 시나리오**까지 포함한 완성도 높은 구현 계획 수립

---

## 2. 쿠폰 기능 개선

### 2.1 현황 요약
- **현재 구현 상태**:
  - 쿠폰 정보: `model/Coupon`, `CouponMapper.xml`을 통해 발급/조회/수정까지 지원
  - 사용자 쿠폰: `model/UserCoupon` + `UserCouponMapper.xml`로 사용자별 지급·사용 여부 관리
  - 관리자 플로우: `CouponCreateServlet`, `CouponManagementServlet`에서 생성/수정/비활성화 처리
  - 사용자 플로우: `RestaurantDetailServlet` 노출, `MypageServlet`에서 사용 처리 (`user_coupons.is_used`만 갱신)

- **미비점 (Critical Issues)**
  1. ❌ `coupons.usage_count`가 증가하지 않아 `usage_limit`이 무의미함
  2. ❌ `per_user_limit`, 유효기간, 최소주문금액 검증이 클라이언트 의존 (서버 검증 부재)
  3. ❌ 쿠폰 지급 로직 부재 (`UserCouponService.giveCouponToUser` 미사용)
  4. ❌ **결제/예약 로직과 미연동** (실제 정산 금액에 반영되지 않음)
  5. ❌ 결제 실패 시 쿠폰 롤백 로직 없음

### 2.2 개선 목표
1. **쿠폰 사용 로깅 강화**
   - 쿠폰 사용 시 `coupons.usage_count` 증가 및 사용 가능 여부 재검증
   - `per_user_limit`, `valid_from/valid_to`, `min_order_amount`를 서버에서 필수 체크
   - 사용자 세션 검증 (다른 사용자의 쿠폰 사용 방지)

2. **쿠폰 지급/회수 API 확장**
   - 이벤트·마케팅에서 호출할 수 있는 지급 서비스 (`UserCouponService.giveCouponToUser` 개선 및 노출)
   - 관리자 수동 지급/회수 화면 (선택 구현)

3. **예약·결제 연계 (핵심)**
   - `ReservationServlet`에서 쿠폰 선택 → 주문 금액 할인 계산
   - `NaverPayService`의 depositAmount에서 할인 반영
   - 결제 성공/실패 시 쿠폰 상태 롤백 처리

### 2.3 데이터 모델 및 처리 보강

#### 2.3.1 DB 스키마 추가/수정
```sql
-- 예약-쿠폰 매핑 (reservations 테이블에 FK 추가)
ALTER TABLE reservations
  ADD COLUMN user_coupon_id BIGINT NULL AFTER deposit_amount,
  ADD COLUMN coupon_discount_amount DECIMAL(10,2) DEFAULT 0 AFTER user_coupon_id,
  ADD CONSTRAINT fk_reservations_user_coupon
    FOREIGN KEY (user_coupon_id) REFERENCES user_coupons(id) ON DELETE SET NULL;

-- 중복 지급 방지 인덱스 (단일 쿠폰인 경우)
ALTER TABLE user_coupons
  ADD UNIQUE INDEX ux_user_coupon_single (user_id, coupon_id, is_used);
  -- is_used=0일 때만 유니크 제약 적용 (MySQL 8.0+ partial index 또는 트리거로 대체)

-- 쿠폰 사용 로그 테이블 (선택 사항 - 상세 이력 추적용)
CREATE TABLE IF NOT EXISTS coupon_usage_logs (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_coupon_id BIGINT NOT NULL,
  reservation_id INT NULL,
  action ENUM('USE', 'ROLLBACK') NOT NULL,
  discount_amount DECIMAL(10,2) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_coupon_id) REFERENCES user_coupons(id),
  FOREIGN KEY (reservation_id) REFERENCES reservations(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 2.3.2 사용 제한 검증 로직
- **서버 측 검증 필수 항목**:
  1. `coupon.is_active = true` 확인
  2. `coupon.valid_from <= NOW() <= coupon.valid_to` 확인
  3. `coupon.usage_count < coupon.usage_limit` 확인
  4. `user_coupons.is_used = false` 확인
  5. 해당 사용자가 이미 `per_user_limit`만큼 받았는지 확인
  6. 주문 금액 >= `coupon.min_order_amount` 확인
  7. **세션 userId == user_coupons.user_id** 확인 (보안)

#### 2.3.3 트랜잭션 처리
```java
// ReservationService.java - 예약 생성 시 쿠폰 적용 예시
public boolean createReservationWithCoupon(Reservation reservation, Long userCouponId) {
    SqlSession session = MyBatisSqlSessionFactory.getSqlSession();
    try {
        // 1. 쿠폰 검증 및 할인 계산
        if (userCouponId != null) {
            UserCoupon userCoupon = session.selectOne("UserCouponMapper.findById", userCouponId);
            Coupon coupon = session.selectOne("CouponMapper.findById", userCoupon.getCouponId());

            // 검증
            if (!validateCoupon(userCoupon, coupon, reservation.getUserId(), reservation.getDepositAmount())) {
                throw new IllegalArgumentException("쿠폰 사용 불가");
            }

            // 할인 계산
            BigDecimal discount = calculateDiscount(coupon, reservation.getDepositAmount());
            reservation.setUserCouponId(userCouponId);
            reservation.setCouponDiscountAmount(discount);
            reservation.setDepositAmount(reservation.getDepositAmount().subtract(discount));
        }

        // 2. 예약 생성
        session.insert("ReservationMapper.insert", reservation);

        // 3. 쿠폰 상태 변경 (결제 전에는 변경하지 않음 - 결제 성공 시에만)
        // 이 시점에서는 예약만 생성하고, 결제 성공 시 NaverPayCallbackServlet에서 처리

        session.commit();
        return true;
    } catch (Exception e) {
        session.rollback();
        throw e;
    } finally {
        session.close();
    }
}

private boolean validateCoupon(UserCoupon userCoupon, Coupon coupon, int userId, BigDecimal orderAmount) {
    if (userCoupon.getUserId() != userId) return false; // 보안 체크
    if (userCoupon.isUsed()) return false;
    if (!coupon.isActive()) return false;
    if (coupon.getValidFrom() != null && LocalDateTime.now().isBefore(coupon.getValidFrom())) return false;
    if (coupon.getValidTo() != null && LocalDateTime.now().isAfter(coupon.getValidTo())) return false;
    if (coupon.getUsageCount() >= coupon.getUsageLimit()) return false;
    if (orderAmount.compareTo(coupon.getMinOrderAmount()) < 0) return false;
    return true;
}

private BigDecimal calculateDiscount(Coupon coupon, BigDecimal orderAmount) {
    BigDecimal discount = BigDecimal.ZERO;
    if ("FIXED".equals(coupon.getDiscountType())) {
        discount = coupon.getDiscountValue();
    } else if ("PERCENT".equals(coupon.getDiscountType())) {
        discount = orderAmount.multiply(coupon.getDiscountValue()).divide(new BigDecimal(100));
        if (coupon.getMaxDiscountAmount() != null) {
            discount = discount.min(coupon.getMaxDiscountAmount());
        }
    }
    return discount.setScale(2, RoundingMode.DOWN);
}
```

### 2.4 구현 단계 (상세)

| 단계 | 작업 내용 | 수정/추가 파일 | 핵심 코드 | 검증 방법 |
|------|-----------|----------------|-----------|-----------|
| **1** | **DB 스키마 수정** | `database/master.sql` | 상기 2.3.1 SQL 실행 | `DESCRIBE reservations;` 확인 |
| **2** | **UserCouponService 검증 로직 추가** | `service/UserCouponService.java` | `validateCouponUsable(userCouponId, userId, orderAmount)` 메서드 추가 | JUnit 단위 테스트 |
| **3** | **CouponMapper에 usage_count 증가 쿼리 추가** | `mappers/CouponMapper.xml` | `<update id="incrementUsageCount">UPDATE coupons SET usage_count = usage_count + 1 WHERE id = #{id} AND usage_count < usage_limit</update>` | MyBatis 로그 확인 |
| **4** | **예약 생성 화면에 쿠폰 선택 UI 추가** | `WEB-INF/views/create-reservation.jsp` | 171라인 이후에 `<select id="userCouponId" name="userCouponId"><option value="">쿠폰 선택 안함</option><c:forEach items="${availableCoupons}" var="c"><option value="${c.id}">${c.couponName} (${c.discountDisplay})</option></c:forEach></select>` 추가 | 브라우저에서 UI 확인 |
| **5** | **ReservationServlet에서 쿠폰 처리** | `controller/ReservationServlet.java` | `handleReservationCreateSubmit` 메서드에서 `userCouponId` 파라미터 받아서 `ReservationService.createReservationWithCoupon` 호출 | 디버거로 discount 계산 확인 |
| **6** | **결제 성공 시 쿠폰 사용 처리** | `controller/payment/NaverPayCallbackServlet.java` | `persistPayment` 메서드 후에 `if (reservation.getUserCouponId() != null) { userCouponService.markAsUsed(reservation.getUserCouponId()); couponService.incrementUsageCount(reservation.getCouponId()); }` 추가 | DB에서 `is_used=1`, `usage_count` 증가 확인 |
| **7** | **결제 실패/취소 시 롤백 처리** | `controller/payment/NaverPayCallbackServlet.java` | `handleFailure` 메서드에서 쿠폰 상태 롤백 (필요 시 `user_coupons.is_used=0`으로 복원, 단 결제 전에는 변경 안 했으므로 생략 가능) | 결제 실패 시나리오 테스트 |
| **8** | **관리자 쿠폰 지급 API (선택)** | `controller/admin/CouponIssueServlet.java` (신규) | `POST /admin/coupon/issue` - `UserCouponService.giveCouponToUser(userId, couponId)` 호출 | Postman으로 API 테스트 |

### 2.5 테스트 / 검증 (구체화)

#### 2.5.1 단위 테스트 (JUnit 5 + MyBatis Test)
```java
@ExtendWith(MockitoExtension.class)
class UserCouponServiceTest {
    @Mock private UserCouponMapper mapper;
    @InjectMocks private UserCouponService service;

    @Test
    void 쿠폰_검증_성공() {
        // Given
        UserCoupon uc = new UserCoupon(1L, 100L, 5L, false);
        Coupon c = new Coupon(5L, "10% 할인", "PERCENT", new BigDecimal(10), true,
                              LocalDateTime.now().minusDays(1), LocalDateTime.now().plusDays(1),
                              new BigDecimal(5000), 100, 0);
        when(mapper.findById(1L)).thenReturn(uc);
        when(mapper.findCouponById(5L)).thenReturn(c);

        // When
        boolean result = service.validateCouponUsable(1L, 100L, new BigDecimal(10000));

        // Then
        assertTrue(result);
    }

    @Test
    void 쿠폰_검증_실패_다른사용자() {
        // Given
        UserCoupon uc = new UserCoupon(1L, 100L, 5L, false);
        when(mapper.findById(1L)).thenReturn(uc);

        // When/Then
        assertThrows(SecurityException.class, () ->
            service.validateCouponUsable(1L, 999L, new BigDecimal(10000))
        );
    }
}
```

#### 2.5.2 통합 테스트 시나리오
1. **시나리오 A: 쿠폰 사용 성공**
   ```
   1. 사용자 로그인 (userId=10)
   2. /reservation/create 페이지 접근 → 사용 가능 쿠폰 목록 조회
   3. 예약 생성 (restaurantId=33, userCouponId=7, depositAmount=10000)
   4. 할인 계산 (10% 쿠폰 → 9000원으로 감소)
   5. 네이버페이 결제 (9000원)
   6. 결제 성공 → user_coupons.is_used=1, coupons.usage_count+1 확인
   ```

2. **시나리오 B: 쿠폰 검증 실패**
   ```
   1. 만료된 쿠폰 선택 → 서버 에러 메시지 "쿠폰이 만료되었습니다" 확인
   2. 최소 주문 금액 미달 → "최소 주문 금액 5000원 이상이어야 합니다" 확인
   3. 이미 사용한 쿠폰 → "이미 사용된 쿠폰입니다" 확인
   ```

3. **시나리오 C: 결제 실패 시 롤백**
   ```
   1. 쿠폰 선택 후 예약 생성
   2. 네이버페이에서 결제 실패 (카드 한도 초과 등)
   3. user_coupons.is_used 상태 변경 없음 확인 (결제 전에는 변경 안 함)
   4. 재시도 시 동일 쿠폰 사용 가능 확인
   ```

#### 2.5.3 회귀 테스트
- 기존 쿠폰 관리 화면 (`/coupon-management`) 정상 동작 확인
- MyPage 쿠폰 탭에서 사용 이력 표시 확인
- 쿠폰 없는 예약 생성 정상 작동 확인

---

## 3. 포인트 시스템 신규 구축

### 3.1 요구사항 요약
- 사용자 활동(결제, 리뷰 등)에 따라 적립·차감되는 포인트 계좌 도입
- 포인트 사용 시 주문 금액 일부를 대체하고, 사용/환불 이력 추적
- 만료 정책, 관리자 수동 조정, 마이페이지 조회 기능 포함
- **동시성 제어** 및 **정합성 보장** 필수

### 3.2 아키텍처 제안

#### 3.2.1 DB 스키마
```sql
-- 사용자 포인트 잔액 테이블
CREATE TABLE user_points (
  user_id INT PRIMARY KEY,
  balance INT NOT NULL DEFAULT 0 CHECK (balance >= 0),
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 포인트 거래 내역 테이블
CREATE TABLE point_transactions (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id INT NOT NULL,
  change_amount INT NOT NULL COMMENT '양수: 적립, 음수: 차감',
  type ENUM('EARN', 'REDEEM', 'REFUND', 'EXPIRE', 'ADMIN') NOT NULL,
  reference_type ENUM('RESERVATION', 'REVIEW', 'PAYMENT', 'CANCEL', 'MANUAL') NULL,
  reference_id BIGINT NULL COMMENT '참조 ID (예약 ID, 리뷰 ID 등)',
  balance_after INT NOT NULL COMMENT '거래 후 잔액 (검증용)',
  expires_at DATE NULL COMMENT '만료일 (적립 시에만 설정)',
  memo VARCHAR(500) NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  INDEX idx_user_created (user_id, created_at DESC),
  INDEX idx_expires (expires_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- reservations 테이블에 포인트 사용 컬럼 추가
ALTER TABLE reservations
  ADD COLUMN points_used INT DEFAULT 0 AFTER coupon_discount_amount,
  ADD COLUMN points_earned INT DEFAULT 0 AFTER points_used;
```

#### 3.2.2 도메인/DAO/서비스
```java
// model/PointBalance.java
public class PointBalance {
    private int userId;
    private int balance;
    private LocalDateTime updatedAt;
    // getters/setters
}

// model/PointTransaction.java
public class PointTransaction {
    private Long id;
    private int userId;
    private int changeAmount;
    private String type; // EARN, REDEEM, REFUND, EXPIRE, ADMIN
    private String referenceType; // RESERVATION, REVIEW, PAYMENT, CANCEL, MANUAL
    private Long referenceId;
    private int balanceAfter;
    private LocalDate expiresAt;
    private String memo;
    private LocalDateTime createdAt;
    // getters/setters
}

// dao/PointDAO.java
public interface PointDAO {
    PointBalance getBalance(int userId);
    void initBalance(int userId); // 최초 0원으로 초기화
    int updateBalance(int userId, int changeAmount); // 원자적 업데이트, 반환값: 영향받은 행 수
    void insertTransaction(PointTransaction transaction);
    List<PointTransaction> findTransactions(int userId, String type, int offset, int limit);
    int sumExpiringPoints(int userId, LocalDate beforeDate); // 만료 예정 포인트 합계
}

// service/PointService.java
@Service
public class PointService {
    private final PointDAO pointDAO;
    private static final int EXPIRE_DAYS = 365; // 1년 후 만료

    // 포인트 적립
    public void awardPoints(int userId, int amount, String referenceType, Long referenceId) {
        SqlSession session = MyBatisSqlSessionFactory.getSqlSession();
        try {
            // 1. 잔액 초기화 (없으면)
            if (pointDAO.getBalance(userId) == null) {
                pointDAO.initBalance(userId);
            }

            // 2. 동시성 제어를 위한 원자적 업데이트
            int rows = session.update("PointMapper.updateBalance",
                Map.of("userId", userId, "changeAmount", amount));

            if (rows == 0) {
                throw new IllegalStateException("포인트 업데이트 실패");
            }

            // 3. 거래 내역 기록
            PointBalance balance = pointDAO.getBalance(userId);
            PointTransaction tx = new PointTransaction();
            tx.setUserId(userId);
            tx.setChangeAmount(amount);
            tx.setType("EARN");
            tx.setReferenceType(referenceType);
            tx.setReferenceId(referenceId);
            tx.setBalanceAfter(balance.getBalance());
            tx.setExpiresAt(LocalDate.now().plusDays(EXPIRE_DAYS));
            tx.setMemo("적립: " + referenceType);

            pointDAO.insertTransaction(tx);
            session.commit();
        } catch (Exception e) {
            session.rollback();
            throw e;
        } finally {
            session.close();
        }
    }

    // 포인트 차감
    public void redeemPoints(int userId, int amount, String referenceType, Long referenceId) {
        SqlSession session = MyBatisSqlSessionFactory.getSqlSession();
        try {
            PointBalance balance = pointDAO.getBalance(userId);
            if (balance == null || balance.getBalance() < amount) {
                throw new IllegalArgumentException("포인트 잔액 부족");
            }

            // 원자적 차감 (잔액 부족 시 실패)
            int rows = session.update("PointMapper.redeemBalance",
                Map.of("userId", userId, "changeAmount", amount, "minBalance", amount));

            if (rows == 0) {
                throw new IllegalStateException("포인트 잔액 부족 또는 동시성 충돌");
            }

            // 거래 내역 기록
            PointBalance newBalance = pointDAO.getBalance(userId);
            PointTransaction tx = new PointTransaction();
            tx.setUserId(userId);
            tx.setChangeAmount(-amount);
            tx.setType("REDEEM");
            tx.setReferenceType(referenceType);
            tx.setReferenceId(referenceId);
            tx.setBalanceAfter(newBalance.getBalance());
            tx.setMemo("사용: " + referenceType);

            pointDAO.insertTransaction(tx);
            session.commit();
        } catch (Exception e) {
            session.rollback();
            throw e;
        } finally {
            session.close();
        }
    }

    // 환불
    public void refundPoints(int userId, int amount, String referenceType, Long referenceId) {
        awardPoints(userId, amount, referenceType, referenceId); // 동일 로직 재사용
        // type만 REFUND로 변경 필요 시 별도 구현
    }

    // 잔액 조회
    public int getBalance(int userId) {
        PointBalance balance = pointDAO.getBalance(userId);
        return balance != null ? balance.getBalance() : 0;
    }

    // 거래 내역 조회
    public List<PointTransaction> listTransactions(int userId, String type, int page, int pageSize) {
        return pointDAO.findTransactions(userId, type, (page - 1) * pageSize, pageSize);
    }

    // 만료 처리 (배치 작업)
    public void expirePoints() {
        // Quartz Job 또는 스케줄러에서 호출
        // 만료일이 지난 EARN 거래를 찾아서 차감
    }
}
```

#### 3.2.3 MyBatis 매퍼
```xml
<!-- mappers/PointMapper.xml -->
<mapper namespace="mapper.PointMapper">
  <resultMap id="PointBalanceMap" type="model.PointBalance">
    <id property="userId" column="user_id"/>
    <result property="balance" column="balance"/>
    <result property="updatedAt" column="updated_at"/>
  </resultMap>

  <resultMap id="PointTransactionMap" type="model.PointTransaction">
    <id property="id" column="id"/>
    <result property="userId" column="user_id"/>
    <result property="changeAmount" column="change_amount"/>
    <result property="type" column="type"/>
    <result property="referenceType" column="reference_type"/>
    <result property="referenceId" column="reference_id"/>
    <result property="balanceAfter" column="balance_after"/>
    <result property="expiresAt" column="expires_at"/>
    <result property="memo" column="memo"/>
    <result property="createdAt" column="created_at"/>
  </resultMap>

  <select id="getBalance" resultMap="PointBalanceMap">
    SELECT * FROM user_points WHERE user_id = #{userId} FOR UPDATE
  </select>

  <insert id="initBalance">
    INSERT INTO user_points (user_id, balance) VALUES (#{userId}, 0)
    ON DUPLICATE KEY UPDATE balance = balance
  </insert>

  <update id="updateBalance">
    UPDATE user_points
    SET balance = balance + #{changeAmount}, updated_at = NOW()
    WHERE user_id = #{userId}
  </update>

  <update id="redeemBalance">
    UPDATE user_points
    SET balance = balance - #{changeAmount}, updated_at = NOW()
    WHERE user_id = #{userId} AND balance >= #{minBalance}
  </update>

  <insert id="insertTransaction">
    INSERT INTO point_transactions
      (user_id, change_amount, type, reference_type, reference_id, balance_after, expires_at, memo)
    VALUES
      (#{userId}, #{changeAmount}, #{type}, #{referenceType}, #{referenceId}, #{balanceAfter}, #{expiresAt}, #{memo})
  </insert>

  <select id="findTransactions" resultMap="PointTransactionMap">
    SELECT * FROM point_transactions
    WHERE user_id = #{userId}
    <if test="type != null">AND type = #{type}</if>
    ORDER BY created_at DESC
    LIMIT #{offset}, #{limit}
  </select>

  <select id="sumExpiringPoints" resultType="int">
    SELECT COALESCE(SUM(change_amount), 0)
    FROM point_transactions
    WHERE user_id = #{userId}
      AND type = 'EARN'
      AND expires_at &lt;= #{beforeDate}
      AND expires_at IS NOT NULL
  </select>
</mapper>
```

### 3.3 업무 플로우 연계 (상세)

#### 3.3.1 예약 결제 성공 시 포인트 적립
```java
// NaverPayCallbackServlet.java - confirmResult.isSuccess() 블록 내
if (confirmResult.isSuccess()) {
    naverPayService.markPaymentSuccess(reservation, merchantPayKey);
    persistPayment(reservation);

    // 쿠폰 사용 처리
    if (reservation.getUserCouponId() != null) {
        userCouponService.markAsUsed(reservation.getUserCouponId());
        couponService.incrementUsageCount(...);
    }

    // 포인트 적립 (결제 금액의 5%)
    BigDecimal earnRate = new BigDecimal("0.05");
    int earnedPoints = reservation.getDepositAmount()
        .multiply(earnRate)
        .intValue();
    pointService.awardPoints(
        reservation.getUserId(),
        earnedPoints,
        "PAYMENT",
        (long) reservation.getId()
    );

    // 예약에 적립 포인트 기록
    reservation.setPointsEarned(earnedPoints);
    reservationService.updateReservationStatus(reservation.getId(), reservation.getStatus());

    redirectSuccess(request, response);
}
```

#### 3.3.2 예약 생성 시 포인트 사용
```java
// ReservationServlet.handleReservationCreateSubmit - 쿠폰 처리 후
String pointsUsedParam = request.getParameter("pointsUsed");
int pointsUsed = 0;
if (pointsUsedParam != null && !pointsUsedParam.isEmpty()) {
    pointsUsed = Integer.parseInt(pointsUsedParam);

    // 포인트 검증
    int userBalance = pointService.getBalance(user.getId());
    if (pointsUsed > userBalance) {
        throw new Exception("포인트 잔액이 부족합니다.");
    }
    if (pointsUsed > reservation.getDepositAmount().intValue()) {
        throw new Exception("포인트는 결제 금액을 초과할 수 없습니다.");
    }

    // 포인트 차감 (결제 성공 시에만 실제 차감)
    reservation.setPointsUsed(pointsUsed);
    reservation.setDepositAmount(
        reservation.getDepositAmount().subtract(new BigDecimal(pointsUsed))
    );
}

// ... 예약 생성 후 결제 페이지로 이동
```

#### 3.3.3 결제 실패 시 포인트 롤백
```java
// NaverPayCallbackServlet.handleFailure
private void handleFailure(Reservation reservation, String merchantPayKey,
                          HttpServletRequest request, HttpServletResponse response,
                          String message) throws IOException {
    naverPayService.markPaymentFailure(reservation, merchantPayKey);
    persistPayment(reservation);

    // 포인트 사용했다면 롤백 (환불)
    if (reservation.getPointsUsed() > 0) {
        pointService.refundPoints(
            reservation.getUserId(),
            reservation.getPointsUsed(),
            "CANCEL",
            (long) reservation.getId()
        );
    }

    redirectFailure(request, response, message);
}
```

#### 3.3.4 리뷰 작성 시 포인트 적립
```java
// ReviewService.addReview - 리뷰 등록 성공 후
public boolean addReview(Review review) {
    SqlSession session = MyBatisSqlSessionFactory.getSqlSession();
    try {
        session.insert("ReviewMapper.insertReview", review);

        // 리뷰 작성 포인트 적립 (500점)
        pointService.awardPoints(
            review.getUserId(),
            500,
            "REVIEW",
            review.getId()
        );

        session.commit();
        return true;
    } catch (Exception e) {
        session.rollback();
        throw e;
    } finally {
        session.close();
    }
}
```

### 3.4 UI/관리 (상세)

#### 3.4.1 예약 생성 화면에 포인트 사용 UI 추가
```jsp
<!-- create-reservation.jsp - 쿠폰 선택 UI 다음에 추가 -->
<div class="mb-4">
    <label for="pointsUsed" class="block text-sm font-medium text-slate-700 mb-2">
        포인트 사용 (보유: <span id="userPoints">${userPoints}</span>P)
    </label>
    <div class="flex gap-2">
        <input type="number" id="pointsUsed" name="pointsUsed"
               min="0" max="${userPoints}" value="0"
               class="form-input flex-1" placeholder="사용할 포인트 입력">
        <button type="button" onclick="useAllPoints()"
                class="px-4 py-2 bg-blue-500 text-white rounded">
            전액 사용
        </button>
    </div>
    <p class="text-xs text-slate-500 mt-1">
        최종 결제 금액: <span id="finalAmount">${reservation.depositAmount}</span>원
    </p>
</div>

<script>
function useAllPoints() {
    const userPoints = parseInt(document.getElementById('userPoints').textContent);
    const depositAmount = ${reservation.depositAmount};
    const maxUsable = Math.min(userPoints, depositAmount);
    document.getElementById('pointsUsed').value = maxUsable;
    updateFinalAmount();
}

function updateFinalAmount() {
    const deposit = ${reservation.depositAmount};
    const couponDiscount = ${reservation.couponDiscountAmount || 0};
    const pointsUsed = parseInt(document.getElementById('pointsUsed').value) || 0;
    const finalAmount = Math.max(0, deposit - couponDiscount - pointsUsed);
    document.getElementById('finalAmount').textContent = finalAmount.toLocaleString();
}

document.getElementById('pointsUsed').addEventListener('input', updateFinalAmount);
</script>
```

#### 3.4.2 마이페이지 포인트 내역
```jsp
<!-- mypage/points.jsp (신규) -->
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>

<div class="max-w-4xl mx-auto p-6">
    <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
        <h2 class="text-2xl font-bold mb-4">내 포인트</h2>
        <div class="flex items-center justify-between">
            <div>
                <p class="text-sm text-slate-600">보유 포인트</p>
                <p class="text-4xl font-bold text-blue-600">${pointBalance.balance}<span class="text-2xl">P</span></p>
            </div>
            <div class="text-right">
                <p class="text-sm text-slate-600">만료 예정 (30일 내)</p>
                <p class="text-xl font-semibold text-red-600">${expiringPoints}P</p>
            </div>
        </div>
    </div>

    <div class="bg-white rounded-xl shadow-lg p-6">
        <h3 class="text-xl font-semibold mb-4">포인트 내역</h3>
        <table class="w-full">
            <thead>
                <tr class="border-b">
                    <th class="text-left py-2">날짜</th>
                    <th class="text-left py-2">구분</th>
                    <th class="text-right py-2">포인트</th>
                    <th class="text-right py-2">잔액</th>
                </tr>
            </thead>
            <tbody>
                <c:forEach items="${transactions}" var="tx">
                    <tr class="border-b">
                        <td class="py-3">
                            <fmt:formatDate value="${tx.createdAt}" pattern="yyyy-MM-dd HH:mm"/>
                        </td>
                        <td class="py-3">
                            <span class="px-2 py-1 rounded text-xs ${tx.type == 'EARN' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}">
                                ${tx.type}
                            </span>
                            <span class="text-sm text-slate-600 ml-2">${tx.memo}</span>
                        </td>
                        <td class="py-3 text-right ${tx.changeAmount > 0 ? 'text-green-600' : 'text-red-600'}">
                            ${tx.changeAmount > 0 ? '+' : ''}${tx.changeAmount}
                        </td>
                        <td class="py-3 text-right">${tx.balanceAfter}</td>
                    </tr>
                </c:forEach>
            </tbody>
        </table>
    </div>
</div>
```

#### 3.4.3 관리자 포인트 관리 화면 (선택)
```jsp
<!-- admin/point-management.jsp -->
<form method="POST" action="${pageContext.request.contextPath}/admin/points/adjust">
    <select name="userId" required>
        <option value="">사용자 선택</option>
        <c:forEach items="${users}" var="u">
            <option value="${u.id}">${u.nickname} (${u.email})</option>
        </c:forEach>
    </select>
    <input type="number" name="amount" placeholder="포인트 (양수=지급, 음수=차감)" required>
    <input type="text" name="memo" placeholder="사유" required>
    <button type="submit">적용</button>
</form>
```

### 3.5 동시성/정합성 (심화)

#### 3.5.1 동시 요청 경쟁 제어
```xml
<!-- PointMapper.xml - 원자적 업데이트 -->
<update id="redeemBalance">
  UPDATE user_points
  SET balance = balance - #{changeAmount}, updated_at = NOW()
  WHERE user_id = #{userId}
    AND balance >= #{changeAmount}  <!-- 잔액 부족 시 업데이트 실패 -->
</update>
```
- **작동 원리**: MySQL의 `UPDATE ... WHERE` 조건이 만족하지 않으면 `affected rows = 0` 반환 → Java에서 감지하여 예외 발생

#### 3.5.2 트랜잭션 격리 수준
```java
// MyBatisSqlSessionFactory.java - 트랜잭션 설정
public static SqlSession getSqlSessionWithIsolation(TransactionIsolationLevel level) {
    return sqlSessionFactory.openSession(level);
}

// PointService에서 사용
SqlSession session = MyBatisSqlSessionFactory.getSqlSessionWithIsolation(
    TransactionIsolationLevel.READ_COMMITTED
);
```

#### 3.5.3 Optimistic Locking (선택적 구현)
```sql
-- user_points에 version 컬럼 추가 (낙관적 잠금)
ALTER TABLE user_points ADD COLUMN version INT DEFAULT 0;

-- 업데이트 시 version 체크
UPDATE user_points
SET balance = balance + #{changeAmount},
    version = version + 1,
    updated_at = NOW()
WHERE user_id = #{userId} AND version = #{expectedVersion}
```

### 3.6 구현 단계 (상세)

| 단계 | 작업 내용 | 수정/추가 파일 | 핵심 코드 | 검증 방법 |
|------|-----------|----------------|-----------|-----------|
| **A** | **DB 테이블 추가** | `database/master.sql` | 상기 3.2.1 SQL 실행 | `SHOW TABLES LIKE 'user_points%';` |
| **B** | **모델 클래스 생성** | `model/PointBalance.java`, `model/PointTransaction.java` | POJO 정의 | 컴파일 확인 |
| **C** | **DAO/Mapper 구현** | `dao/PointDAO.java`, `mappers/PointMapper.xml` | 상기 3.2.3 코드 | MyBatis 로그 `DEBUG` 레벨로 쿼리 확인 |
| **D** | **PointService 구현** | `service/PointService.java` | 상기 3.2.2 코드 | JUnit 단위 테스트 (동시성 테스트 포함) |
| **E** | **결제 성공 시 적립** | `controller/payment/NaverPayCallbackServlet.java` | 상기 3.3.1 코드 | 결제 후 `point_transactions` 테이블 확인 |
| **F** | **예약 생성 시 포인트 사용 UI** | `WEB-INF/views/create-reservation.jsp` | 상기 3.4.1 코드 | 브라우저에서 UI 동작 확인 |
| **G** | **포인트 사용 로직** | `controller/ReservationServlet.java` | 상기 3.3.2 코드 | 디버거로 `pointsUsed` 값 추적 |
| **H** | **결제 실패 시 롤백** | `controller/payment/NaverPayCallbackServlet.java` | 상기 3.3.3 코드 | 결제 실패 → 포인트 환불 확인 |
| **I** | **리뷰 작성 적립** | `service/ReviewService.java` | 상기 3.3.4 코드 | 리뷰 작성 후 500P 적립 확인 |
| **J** | **마이페이지 UI** | `WEB-INF/views/mypage/points.jsp` (신규), `controller/MypageServlet.java` | 상기 3.4.2 코드 | `/mypage/points` 접근 테스트 |
| **K** | **만료 배치 (선택)** | `batch/PointExpirationJob.java` (Quartz) | Quartz Scheduler 설정 | 스케줄러 로그 확인 |

### 3.7 테스트 / 검증 (구체화)

#### 3.7.1 단위 테스트 (동시성 포함)
```java
@Test
void 포인트_동시_차감_테스트() throws InterruptedException {
    // Given
    int userId = 100;
    pointService.awardPoints(userId, 1000, "MANUAL", null);

    ExecutorService executor = Executors.newFixedThreadPool(10);
    CountDownLatch latch = new CountDownLatch(10);
    AtomicInteger successCount = new AtomicInteger(0);

    // When - 10개 스레드가 동시에 200P씩 차감 시도 (총 2000P, 잔액은 1000P)
    for (int i = 0; i < 10; i++) {
        executor.submit(() -> {
            try {
                pointService.redeemPoints(userId, 200, "TEST", null);
                successCount.incrementAndGet();
            } catch (IllegalStateException e) {
                // 잔액 부족으로 실패 (예상된 동작)
            } finally {
                latch.countDown();
            }
        });
    }
    latch.await();

    // Then - 5개만 성공해야 함 (1000P / 200P = 5)
    assertEquals(5, successCount.get());
    assertEquals(0, pointService.getBalance(userId)); // 잔액 0
}
```

#### 3.7.2 통합 테스트 시나리오
1. **시나리오 A: 포인트 적립 및 사용**
   ```
   1. 리뷰 작성 → 500P 적립 확인
   2. 예약 생성 시 300P 사용 → 잔액 200P 확인
   3. 결제 성공 → 결제 금액의 5% 추가 적립
   4. 마이페이지에서 거래 내역 확인
   ```

2. **시나리오 B: 잔액 부족 시 에러 처리**
   ```
   1. 보유 포인트 100P
   2. 예약 시 200P 사용 시도 → "포인트 잔액 부족" 에러 메시지 확인
   ```

3. **시나리오 C: 결제 실패 시 포인트 환불**
   ```
   1. 300P 사용하여 예약 생성 (잔액 500P → 200P)
   2. 결제 실패 → 포인트 300P 환불 (잔액 200P → 500P)
   3. 거래 내역에 REFUND 타입으로 기록 확인
   ```

#### 3.7.3 회귀 테스트
- 포인트 없는 예약 생성 정상 작동 확인
- 기존 결제 플로우 영향 없음 확인
- 리뷰 시스템 정상 작동 확인

---

## 4. 텔레그램 알림 연동 계획 (Tomcat 9 · Java 11 · Maven · MyBatis)

### 4.1 전제 · 환경
- **목표**: 회원별 텔레그램 DM 알림 발송
  ➜ 전화번호만으로 발송 불가하므로 사용자 `/start` 온보딩이 반드시 선행되어야 함
- **런타임**: JDK 11, Tomcat 9 (Servlet 4.0 `javax.*`), Maven, MyBatis
- **프로젝트 구조**
  ```
  MEETLOG/MeetLog/
    └─ src/
       ├─ main/java/            # Java
       ├─ main/resources/       # ✔ api.properties
       └─ main/webapp/          # JSP/정적
  ```
- **설정 파일** (`src/main/resources/api.properties`)
  ```properties
  telegram.bot.token=123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11
  telegram.bot.name=meetlog_bot
  telegram.baseUrl=https://api.telegram.org
  telegram.poll.timeout=50
  ```
- **Maven 의존성** (Jackson 필수)
  ```xml
  <dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
  </dependency>
  <dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.17.1</version>
  </dependency>
  ```

### 4.2 데이터 모델
```sql
-- tg_link 테이블 정의
CREATE TABLE tg_link (
  id           BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id      INT NOT NULL COMMENT '회원 ID (users.id)',
  tg_user_id   BIGINT NULL COMMENT '텔레그램 사용자 ID',
  chat_id      VARCHAR(32) NULL COMMENT '채팅방 ID (DM용)',
  start_token  VARCHAR(64) NOT NULL UNIQUE COMMENT '온보딩 토큰',
  state        ENUM('PENDING','ACTIVE','BLOCKED') NOT NULL DEFAULT 'PENDING',
  created_at   TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at   TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY ux_tg_user (user_id),
  KEY ix_tg_state (state),
  KEY ix_start_token (start_token),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**상태 전이**
- `PENDING` (토큰 발급) → `/start TOKEN` 수신 시 `ACTIVE`로 전환하며 `chat_id/tg_user_id` 저장
- 발송 시 403(차단) 발생 → `BLOCKED`로 전환하여 재온보딩 필요

### 4.3 온보딩 플로우 (/start 딥링크)

#### 4.3.1 사용자 플로우
1. 마이페이지에서 **텔레그램 연결** 버튼 클릭
2. 서버가 토큰 발급 후 `tg_link`에 `PENDING` 상태로 upsert
3. 사용자에게 `https://t.me/<bot>?start=TOKEN` 딥링크 전달 (QR 코드 또는 버튼)
4. 사용자가 Start → 봇이 `/start TOKEN` 수신
5. 폴러가 토큰을 소비해 `ACTIVE`로 전환하고 환영 메시지 발송

#### 4.3.2 토큰 발급 서블릿
```java
package controller.telegram;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;
import java.io.IOException;
import org.apache.ibatis.session.SqlSession;
import util.MyBatisSqlSessionFactory;

@WebServlet("/member/telegram/link")
public class TelegramLinkServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        HttpSession session = req.getSession(false);
        if (session == null || session.getAttribute("user") == null) {
            resp.setStatus(401);
            resp.getWriter().write("{\"error\":\"로그인 필요\"}");
            return;
        }

        int userId = ((model.User) session.getAttribute("user")).getId();
        String token = java.util.UUID.randomUUID().toString().replace("-", "");

        SqlSession sqlSession = MyBatisSqlSessionFactory.getSqlSession();
        try {
            sqlSession.insert("TgLinkMapper.upsertPending",
                java.util.Map.of("userId", userId, "token", token));
            sqlSession.commit();
        } finally {
            sqlSession.close();
        }

        String botName = util.AppConfig.getProperty("telegram.bot.name", "meetlog_bot");
        String deepLink = "https://t.me/" + botName + "?start=" + token;

        resp.setContentType("application/json;charset=UTF-8");
        resp.getWriter().write("{\"deepLink\":\""+deepLink+"\"}");
    }
}
```

#### 4.3.3 JSP UI (마이페이지)
```jsp
<!-- mypage.jsp - 알림 설정 탭 -->
<div class="bg-white rounded-xl shadow-lg p-6">
    <h3 class="text-xl font-semibold mb-4">텔레그램 알림 설정</h3>
    <div id="tg-status">
        <c:choose>
            <c:when test="${tgLink != null && tgLink.state == 'ACTIVE'}">
                <p class="text-green-600">✅ 연결됨 (chat_id: ${tgLink.chatId})</p>
                <button onclick="unlinkTelegram()" class="mt-2 px-4 py-2 bg-red-500 text-white rounded">
                    연결 해제
                </button>
            </c:when>
            <c:when test="${tgLink != null && tgLink.state == 'BLOCKED'}">
                <p class="text-red-600">❌ 차단됨 (재연결 필요)</p>
                <button onclick="linkTelegram()" class="mt-2 px-4 py-2 bg-blue-500 text-white rounded">
                    재연결
                </button>
            </c:when>
            <c:otherwise>
                <p class="text-slate-600">텔레그램 알림을 받으려면 봇을 연결하세요</p>
                <button onclick="linkTelegram()" class="mt-2 px-4 py-2 bg-blue-500 text-white rounded">
                    텔레그램 연결
                </button>
            </c:otherwise>
        </c:choose>
    </div>
    <div id="tg-deeplink" class="mt-4 hidden">
        <p class="text-sm text-slate-600">아래 링크를 클릭하여 봇을 시작하세요:</p>
        <a id="deeplink-url" href="#" target="_blank"
           class="text-blue-600 underline break-all"></a>
    </div>
</div>

<script>
function linkTelegram() {
    fetch('${pageContext.request.contextPath}/member/telegram/link', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'}
    })
    .then(res => res.json())
    .then(data => {
        if (data.deepLink) {
            document.getElementById('deeplink-url').href = data.deepLink;
            document.getElementById('deeplink-url').textContent = data.deepLink;
            document.getElementById('tg-deeplink').classList.remove('hidden');
            alert('텔레그램 봇을 시작해주세요!');
        }
    });
}

function unlinkTelegram() {
    if (confirm('텔레그램 연결을 해제하시겠습니까?')) {
        fetch('${pageContext.request.contextPath}/member/telegram/unlink', {method: 'POST'})
        .then(() => location.reload());
    }
}
</script>
```

### 4.4 폴링 아키텍처 (온보딩 전용)

#### 4.4.1 폴러 리스너 (ServletContextListener)
```java
package telegram;

import javax.servlet.*;
import javax.servlet.annotation.WebListener;
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.Properties;
import java.util.concurrent.*;
import com.fasterxml.jackson.databind.*;
import org.apache.ibatis.session.SqlSession;
import util.MyBatisSqlSessionFactory;

@WebListener
public class OnboardingPoller implements ServletContextListener {
    private ExecutorService loop;
    private volatile boolean running;
    private final ObjectMapper om = new ObjectMapper();
    private String token, baseUrl;
    private int pollTimeout;

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        Properties p = loadProps("api.properties");
        token = envOr(p, "telegram.bot.token", "TG_TOKEN");
        baseUrl = p.getProperty("telegram.baseUrl", "https://api.telegram.org");
        pollTimeout = Integer.parseInt(p.getProperty("telegram.poll.timeout", "50"));

        ServletContext ctx = sce.getServletContext();
        synchronized (ctx) {
            if (ctx.getAttribute("tgOnboardingStarted") != null) return;
            ctx.setAttribute("tgOnboardingStarted", Boolean.TRUE);
        }

        running = true;
        loop = Executors.newSingleThreadExecutor(r -> {
            var t = new Thread(r, "tg-onboarding");
            t.setDaemon(true);
            return t;
        });
        loop.execute(this::pollLoop);
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        running = false;
        if (loop != null) { loop.shutdownNow(); }
    }

    private void pollLoop() {
        HttpClient http = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10)).build();
        long offset = 0;
        long backoff = 1000;

        while (running && !Thread.currentThread().isInterrupted()) {
            try {
                String url = String.format("%s/bot%s/getUpdates?timeout=%d&offset=%d",
                    baseUrl, token, pollTimeout, offset);
                HttpRequest req = HttpRequest.newBuilder(URI.create(url))
                    .timeout(Duration.ofSeconds(Math.max(10, pollTimeout + 10)))
                    .GET().build();
                HttpResponse<String> res = http.send(req, HttpResponse.BodyHandlers.ofString());

                if (res.statusCode() != 200) {
                    throw new IOException("HTTP " + res.statusCode());
                }

                var root = om.readTree(res.body());
                if (root.path("ok").asBoolean(false)) {
                    for (var n : root.withArray("result")) {
                        long updateId = n.path("update_id").asLong();
                        handleStart(n);
                        offset = Math.max(offset, updateId + 1);
                    }
                }
                backoff = 1000;
            } catch (Exception e) {
                System.err.println("Telegram polling error: " + e.getMessage());
                try { Thread.sleep(backoff); }
                catch (InterruptedException ie) { Thread.currentThread().interrupt(); }
                backoff = Math.min(backoff * 2, 30000);
            }
        }
    }

    private void handleStart(JsonNode u) {
        var msg = u.get("message");
        if (msg == null || !msg.has("text")) return;
        String text = msg.get("text").asText("");
        if (!text.startsWith("/start")) return;

        String token = extractToken(text);
        if (token == null) return;
        long chatId  = msg.get("chat").get("id").asLong();
        long tgUser  = msg.get("from").get("id").asLong();

        SqlSession session = MyBatisSqlSessionFactory.getSqlSession();
        try {
            Integer userId = session.selectOne("TgLinkMapper.consumePending", token);
            if (userId != null) {
                session.update("TgLinkMapper.activate",
                    java.util.Map.of("userId", userId,
                                     "chatId", String.valueOf(chatId),
                                     "tgUserId", String.valueOf(tgUser)));
                session.commit();

                // 환영 메시지 발송
                new TelegramSender(loadProps("api.properties"))
                    .sendText(String.valueOf(chatId), "🎉 MEETLOG 알림 연결이 완료되었습니다!");
            }
        } finally {
            session.close();
        }
    }

    private static String extractToken(String text){
        String[] parts = text.trim().split("\\s+");
        return parts.length >= 2 ? parts[1] : null;
    }

    private static Properties loadProps(String name) {
        try (InputStream in = Thread.currentThread().getContextClassLoader()
                .getResourceAsStream(name)) {
            Properties p = new Properties();
            if (in != null) p.load(in);
            return p;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static String envOr(Properties p, String key, String envKey){
        String v = System.getenv(envKey);
        return (v != null && !v.isBlank()) ? v : p.getProperty(key);
    }
}
```

#### 4.4.2 web.xml 리스너 등록
```xml
<!-- web.xml -->
<listener>
  <listener-class>telegram.OnboardingPoller</listener-class>
</listener>
```

### 4.5 메시지 발송 API
```java
package telegram;

import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.Properties;

public class TelegramSender {
    private final String token, baseUrl;
    private final HttpClient http = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(10)).build();

    public TelegramSender(Properties p) {
        this.token  = p.getProperty("telegram.bot.token");
        this.baseUrl= p.getProperty("telegram.baseUrl", "https://api.telegram.org");
        if (token == null) throw new IllegalStateException("telegram.bot.token 누락");
    }

    public boolean sendText(String chatId, String text) {
        String url = baseUrl + "/bot" + token + "/sendMessage";
        String payload = "{\"chat_id\":\""+chatId+"\",\"text\":\""+escape(text)+"\"}";
        HttpRequest req = HttpRequest.newBuilder(URI.create(url))
            .header("Content-Type","application/json")
            .timeout(Duration.ofSeconds(10))
            .POST(HttpRequest.BodyPublishers.ofString(payload)).build();
        try {
            HttpResponse<Void> res = http.send(req, HttpResponse.BodyHandlers.discarding());
            if (res.statusCode() == 200) return true;
            if (res.statusCode() == 403) return false; // 차단/탈퇴
            if (res.statusCode() == 429) return false; // 속도 제한
            return false;
        } catch (Exception e) {
            System.err.println("Telegram send error: " + e.getMessage());
            return false;
        }
    }

    private static String escape(String s){
        return s.replace("\\","\\\\").replace("\"","\\\"");
    }
}
```

### 4.6 서비스 통합 및 이벤트 연계

#### 4.6.1 AlarmService
```java
package service;

import java.util.Properties;
import telegram.TelegramSender;
import org.apache.ibatis.session.SqlSession;
import util.MyBatisSqlSessionFactory;

public class AlarmService {
    private final TelegramSender sender;

    public AlarmService(Properties p){
        this.sender = new TelegramSender(p);
    }

    public void notifyMember(int userId, String message){
        SqlSession session = MyBatisSqlSessionFactory.getSqlSession();
        try {
            String chatId = session.selectOne("TgLinkMapper.findChatId", userId);
            if (chatId == null) return; // 미연결

            boolean ok = sender.sendText(chatId, message);
            if (!ok) {
                // 403 등 발생 시 상태 전환
                session.update("TgLinkMapper.markBlocked", userId);
                session.commit();
            }
        } finally {
            session.close();
        }
    }
}
```

#### 4.6.2 연계 지점 (상세 코드)

**1) 결제 성공 알림**
```java
// NaverPayCallbackServlet.java - confirmResult.isSuccess() 블록
if (confirmResult.isSuccess()) {
    // ... 기존 처리

    // 텔레그램 알림 발송
    Properties p = util.AppConfig.getProperties();
    AlarmService alarmService = new AlarmService(p);
    alarmService.notifyMember(
        reservation.getUserId(),
        String.format("✅ 결제가 완료되었습니다!\n예약: %s\n날짜: %s\n금액: %,d원",
            reservation.getRestaurantName(),
            reservation.getReservationTime(),
            reservation.getDepositAmount().intValue())
    );

    redirectSuccess(request, response);
}
```

**2) 예약 상태 변경 알림**
```java
// BusinessReservationManagementServlet.java - 예약 승인 시
@Override
protected void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
    String action = request.getParameter("action");
    int reservationId = Integer.parseInt(request.getParameter("reservationId"));

    if ("confirm".equals(action)) {
        reservationService.updateReservationStatus(reservationId, "CONFIRMED");
        Reservation res = reservationService.getReservationById(reservationId);

        // 텔레그램 알림
        AlarmService alarmService = new AlarmService(util.AppConfig.getProperties());
        alarmService.notifyMember(
            res.getUserId(),
            String.format("🎉 예약이 확정되었습니다!\n%s\n%s %d명",
                res.getRestaurantName(),
                res.getReservationTime(),
                res.getPartySize())
        );
    }
    // ...
}
```

**3) 포인트 적립 알림**
```java
// PointService.java - awardPoints 메서드 마지막에
public void awardPoints(int userId, int amount, String referenceType, Long referenceId) {
    // ... 기존 로직

    // 알림 발송 (비동기 권장)
    CompletableFuture.runAsync(() -> {
        AlarmService alarmService = new AlarmService(util.AppConfig.getProperties());
        alarmService.notifyMember(
            userId,
            String.format("💰 포인트 %dP가 적립되었습니다!\n구분: %s", amount, referenceType)
        );
    });
}
```

### 4.7 MyBatis 매퍼
```xml
<!-- mappers/TgLinkMapper.xml -->
<mapper namespace="mapper.TgLinkMapper">
  <insert id="upsertPending">
    INSERT INTO tg_link (user_id, start_token, state)
    VALUES (#{userId}, #{token}, 'PENDING')
    ON DUPLICATE KEY UPDATE
      start_token = VALUES(start_token),
      state='PENDING',
      updated_at=NOW()
  </insert>

  <select id="consumePending" resultType="int">
    SELECT user_id FROM tg_link
    WHERE start_token = #{token} AND state='PENDING'
    FOR UPDATE
  </select>

  <update id="activate">
    UPDATE tg_link
       SET chat_id=#{chatId},
           tg_user_id=#{tgUserId},
           state='ACTIVE',
           updated_at=NOW()
     WHERE user_id=#{userId}
  </update>

  <select id="findChatId" resultType="string">
    SELECT chat_id FROM tg_link
    WHERE user_id=#{userId} AND state='ACTIVE'
  </select>

  <update id="markBlocked">
    UPDATE tg_link
    SET state='BLOCKED', updated_at=NOW()
    WHERE user_id=#{userId}
  </update>
</mapper>
```

### 4.8 보안 · 구성 원칙
- **Secrets 관리**:
  - 환경변수 `TG_TOKEN`이 `api.properties` 보다 우선
  - `api.properties`에는 샘플 값만 커밋 (실제 토큰은 `.gitignore`)
- **네트워크**: 방화벽에서 `api.telegram.org:443` 아웃바운드 허용
- **로깅**:
  - 200 응답은 INFO 생략, 4xx/5xx만 WARN/ERROR로 기록
  - SLF4J 사용 권장: `log.error("Telegram send failed: {}", errorMessage)`

### 4.9 테스트 체크리스트
1. ✅ 딥링크 발급 → 응답 JSON `{"deepLink":"https://t.me/..."}` 검증
2. ✅ `/start TOKEN` 처리 → DB `tg_link.state=ACTIVE`, `chat_id` 저장 확인
3. ✅ 알림 발송 → 실제 텔레그램 앱에서 수신 여부 확인
4. ✅ 사용자 차단 후 발송 → 403 감지 및 `BLOCKED` 전환 확인
5. ✅ 재온보딩 → 새 토큰 발급 및 상태 복구 확인

### 4.10 장애 · 예외 처리
- **네트워크 오류**: 1s → 2s → 4s → … 최대 30s 지수 백오프 후 재시도
- **429(레이트 리밋)**: 응답 헤더 `Retry-After` 해석 후 대기 (구현 필요 시)
- **403(차단)**: `markBlocked`로 상태 전환하고 관리자 대시보드에 알림
- **톰캣 자동 퍼블리시 시 리스너 중복 기동 방지**: `tgOnboardingStarted` 플래그 사용

### 4.11 운영 팁
- 메시지 길이 4096자 이하 유지, 필요 시 분할 전송
- 서식이 필요하면 `parse_mode=HTML` 또는 `parse_mode=Markdown` 옵션 추가
- 그룹/채널 공지는 별도 `chat_id` 저장 후 동일 로직 활용
- 다중 인스턴스 운영 시 폴러는 1개 인스턴스만 가동하도록 분산 락 또는 리더 선출 적용

### 4.12 구현 단계 (상세)

| 단계 | 작업 내용 | 수정/추가 파일 | 핵심 코드 | 검증 방법 |
|------|-----------|----------------|-----------|-----------|
| **1** | **텔레그램 봇 생성** | - | BotFather에서 `/newbot` 실행, 토큰 복사 | `api.properties`에 토큰 저장 |
| **2** | **DB 테이블 추가** | `database/master.sql` | 상기 4.2 SQL | `DESCRIBE tg_link;` |
| **3** | **MyBatis 매퍼 구현** | `mappers/TgLinkMapper.xml` | 상기 4.7 코드 | MyBatis 로그 확인 |
| **4** | **폴러 리스너 구현** | `telegram/OnboardingPoller.java` | 상기 4.4.1 코드 | 톰캣 시작 시 로그 `tg-onboarding thread started` 확인 |
| **5** | **web.xml 리스너 등록** | `WEB-INF/web.xml` | 상기 4.4.2 코드 | 톰캣 재시작 후 폴러 동작 확인 |
| **6** | **TelegramSender 구현** | `telegram/TelegramSender.java` | 상기 4.5 코드 | 단위 테스트로 sendText 호출 |
| **7** | **AlarmService 구현** | `service/AlarmService.java` | 상기 4.6.1 코드 | JUnit으로 notifyMember 테스트 |
| **8** | **토큰 발급 서블릿** | `controller/telegram/TelegramLinkServlet.java` | 상기 4.3.2 코드 | Postman으로 `/member/telegram/link` 테스트 |
| **9** | **마이페이지 UI** | `WEB-INF/views/mypage.jsp` | 상기 4.3.3 코드 | 브라우저에서 연결 버튼 클릭 → 딥링크 생성 확인 |
| **10** | **결제 성공 알림 연동** | `controller/payment/NaverPayCallbackServlet.java` | 상기 4.6.2(1) 코드 | 결제 후 텔레그램 메시지 수신 확인 |
| **11** | **예약 승인 알림 연동** | `controller/BusinessReservationManagementServlet.java` | 상기 4.6.2(2) 코드 | 예약 승인 후 알림 수신 확인 |
| **12** | **포인트 적립 알림 연동** | `service/PointService.java` | 상기 4.6.2(3) 코드 | 포인트 적립 후 알림 수신 확인 |

---

## 5. 일정 및 리스크

### 5.1 예상 소요 기간
| 기능 | 개발 기간 | 테스트 기간 | 총 소요 |
|------|-----------|-------------|---------|
| **쿠폰 기능 보완** | 1주 | 0.5주 | **1.5주** |
| **포인트 시스템** | 2주 | 1주 | **3주** |
| **텔레그램 연동** | 0.5주 | 0.5주 | **1주** |
| **통합 테스트 & 버그 수정** | - | 1주 | **1주** |
| **총계** | - | - | **6.5주** |

### 5.2 Phase별 우선순위
- **Phase 1 (2주)**: 쿠폰 사용 완성 (예약 연동, 롤백 처리)
- **Phase 2 (3주)**: 포인트 적립/사용 (결제 연동, UI)
- **Phase 3 (1주)**: 텔레그램 온보딩 (폴러는 이미 코드 완성됨)
- **Phase 4 (0.5주)**: 통합 테스트 & 버그 수정

### 5.3 리스크 요인 및 대응
| 리스크 | 영향도 | 대응 방안 |
|--------|--------|-----------|
| **결제/예약 로직 복잡도** | 높음 | 자동화 테스트/QA 계획 수립, 단계별 코드 리뷰 |
| **포인트·쿠폰·텔레그램 정산 이슈** | 중간 | 비즈니스 부서 협의, 회계 팀 검증 |
| **동시성 버그 (포인트 잔액)** | 높음 | 부하 테스트 (JMeter), 트랜잭션 격리 수준 조정 |
| **텔레그램 레이트 리밋(429)** | 낮음 | 백오프 로직 구현, 발송 큐 도입 (선택) |
| **사용자 차단(403) 처리 누락** | 중간 | 상태 전환 로직 필수 구현, 모니터링 대시보드 |

---

## 6. 권장 선행 작업

### 6.1 개발 환경 준비
1. ✅ **테스트/스테이징 DB 스냅샷 확보**
   - 운영 DB 덤프 → `database/backup/`
   - 마이그레이션 버전 관리 (Flyway 또는 수동 스크립트)
2. ✅ **MyBatis 로깅 레벨 조정**
   ```xml
   <!-- mybatis-config.xml -->
   <settings>
     <setting name="logImpl" value="SLF4J"/>
   </settings>
   ```
   ```xml
   <!-- logback.xml (resources/) -->
   <logger name="mapper" level="DEBUG"/>
   ```
3. ✅ **JUnit 5 + MyBatis Test 환경 구축**
   ```xml
   <!-- pom.xml -->
   <dependency>
     <groupId>org.junit.jupiter</groupId>
     <artifactId>junit-jupiter</artifactId>
     <version>5.10.0</version>
     <scope>test</scope>
   </dependency>
   ```

### 6.2 정책 문서화
1. 포인트 및 쿠폰 정책 확정
   - 적립률: 결제 금액의 5%
   - 포인트 만료: 1년
   - 쿠폰 중복 사용: 불가 (1회당 1개)
   - 최소 사용 포인트: 100P
2. 텔레그램 메시지 템플릿 정의
   ```
   - 결제 성공: "✅ 결제 완료! 예약: {restaurant}, 날짜: {date}, 금액: {amount}원"
   - 예약 승인: "🎉 예약 확정! {restaurant} {date} {partySize}명"
   - 포인트 적립: "💰 포인트 {amount}P 적립! 구분: {type}"
   ```

### 6.3 QA 시나리오 작성
- **쿠폰 테스트 케이스** (15개):
  1. 유효한 쿠폰 사용 성공
  2. 만료된 쿠폰 사용 실패
  3. 사용 횟수 초과 실패
  4. 최소 주문 금액 미달 실패
  5. 다른 사용자 쿠폰 도용 시도 차단
  6. 결제 실패 시 쿠폰 롤백
  7. ... (추가 9개)

- **포인트 테스트 케이스** (20개):
  1. 결제 성공 시 5% 적립
  2. 포인트 사용 후 잔액 차감
  3. 잔액 부족 시 에러
  4. 동시 요청 시 정합성 (10개 스레드 테스트)
  5. ... (추가 16개)

### 6.4 운영 준비
1. **모니터링 도구**:
   - 텔레그램 발송 실패율 모니터링 (Prometheus + Grafana)
   - 포인트 잔액 불일치 알림 (일 1회 배치 검증)
2. **백업 정책**:
   - `user_points`, `point_transactions` 테이블 일 1회 백업
   - 텔레그램 `tg_link` 테이블 주 1회 백업

---

## 7. 롤백 및 복구 시나리오

### 7.1 쿠폰 롤백 시나리오

#### 7.1.1 결제 실패 시
```java
// NaverPayCallbackServlet.handleFailure
if (reservation.getUserCouponId() != null) {
    // 쿠폰 사용 전으로 복원 (is_used=0) - 단, 결제 전에는 변경 안 했으므로 생략 가능
    // 로그만 남기고 다음 사용 시 재검증으로 처리
    log.warn("결제 실패로 쿠폰 사용 취소: userCouponId={}", reservation.getUserCouponId());
}
```

#### 7.1.2 중복 사용 방지
```sql
-- 트리거로 중복 사용 감지 (선택 사항)
DELIMITER //
CREATE TRIGGER prevent_duplicate_coupon_use
BEFORE UPDATE ON user_coupons
FOR EACH ROW
BEGIN
    IF NEW.is_used = 1 AND OLD.is_used = 1 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '이미 사용된 쿠폰입니다';
    END IF;
END//
DELIMITER ;
```

### 7.2 포인트 롤백 시나리오

#### 7.2.1 결제 취소 시 포인트 환불
```java
// ReservationService.cancelReservation
public boolean cancelReservation(int reservationId, String cancelReason) {
    SqlSession session = MyBatisSqlSessionFactory.getSqlSession();
    try {
        Reservation res = session.selectOne("ReservationMapper.findById", reservationId);

        // 포인트 사용했다면 환불
        if (res.getPointsUsed() > 0) {
            pointService.refundPoints(
                res.getUserId(),
                res.getPointsUsed(),
                "CANCEL",
                (long) reservationId
            );
        }

        // 포인트 적립했다면 차감 (마이너스 거래 기록)
        if (res.getPointsEarned() > 0) {
            pointService.redeemPoints(
                res.getUserId(),
                res.getPointsEarned(),
                "CANCEL",
                (long) reservationId
            );
        }

        // 예약 취소
        res.setStatus("CANCELLED");
        res.setCancelReason(cancelReason);
        res.setCancelledAt(LocalDateTime.now());
        session.update("ReservationMapper.update", res);

        session.commit();
        return true;
    } catch (Exception e) {
        session.rollback();
        throw e;
    } finally {
        session.close();
    }
}
```

#### 7.2.2 데이터 정합성 검증 배치
```java
// batch/PointIntegrityCheckJob.java (Quartz Job)
public void execute(JobExecutionContext context) {
    SqlSession session = MyBatisSqlSessionFactory.getSqlSession();
    try {
        List<Integer> userIds = session.selectList("UserMapper.findAllUserIds");

        for (int userId : userIds) {
            // 1. user_points.balance 조회
            Integer dbBalance = session.selectOne("PointMapper.getBalance", userId);

            // 2. point_transactions 합계 계산
            Integer calculatedBalance = session.selectOne("PointMapper.sumTransactions", userId);

            // 3. 불일치 시 알림
            if (dbBalance != null && calculatedBalance != null &&
                !dbBalance.equals(calculatedBalance)) {
                log.error("포인트 잔액 불일치 발견! userId={}, DB={}, 계산={}",
                    userId, dbBalance, calculatedBalance);

                // 관리자 알림 (텔레그램 또는 이메일)
                alarmService.notifyAdmin(String.format(
                    "⚠️ 포인트 불일치: 사용자 %d, DB=%d, 계산=%d",
                    userId, dbBalance, calculatedBalance));
            }
        }
    } finally {
        session.close();
    }
}
```

### 7.3 텔레그램 연결 복구 시나리오

#### 7.3.1 차단(BLOCKED) 상태 복구
```java
// TelegramLinkServlet - 재연결 요청
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
    // ... (기존 로직과 동일)

    // 차단 상태여도 새 토큰 발급으로 재온보딩 가능
    sqlSession.update("TgLinkMapper.upsertPending",
        Map.of("userId", userId, "token", token));
    // state가 PENDING으로 변경되어 재시작 가능
}
```

#### 7.3.2 발송 실패 시 재시도 큐 (선택 사항)
```java
// AlarmService - 재시도 로직
public void notifyMemberWithRetry(int userId, String message, int maxRetries) {
    for (int i = 0; i < maxRetries; i++) {
        if (notifyMember(userId, message)) {
            return; // 성공
        }
        try { Thread.sleep(1000 * (i + 1)); } // 지수 백오프
        catch (InterruptedException e) { Thread.currentThread().interrupt(); }
    }
    log.error("텔레그램 발송 최종 실패: userId={}, message={}", userId, message);
}
```

---

## 8. 향후 확장 아이디어

### 8.1 쿠폰 & 포인트 통합
- **통합 혜택 분석 대시보드**: 사용자별 쿠폰/포인트 사용 패턴 시각화
- **자동 쿠폰 추천**: 사용자 예약 이력 기반 맞춤 쿠폰 추천 (KoBERT 연동)
- **포인트 선물 기능**: 사용자 간 포인트 이체

### 8.2 ERP/지점 시스템 연동
- 포인트 공유: 본점/지점 통합 포인트 계좌
- 지점별 쿠폰 발급: ERP에서 지점 관리자가 독립적으로 쿠폰 생성

### 8.3 추천 시스템 결합
- **맞춤형 캠페인 자동화**:
  1. KoBERT로 사용자 취향 분석
  2. 취향 맞는 레스토랑 쿠폰 자동 발급
  3. 텔레그램으로 쿠폰 안내 메시지 발송

### 8.4 메시지 큐 도입
- **대량 발송 관리**: RabbitMQ 또는 Kafka로 텔레그램 메시지 큐잉
- **재시도 정책**: Dead Letter Queue로 실패 메시지 재처리

---

## 9. 부록

### 9.1 참고 자료
- MyBatis 공식 문서: https://mybatis.org/mybatis-3/
- Telegram Bot API: https://core.telegram.org/bots/api
- Java 11 HttpClient: https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html

### 9.2 코드 스니펫 모음
- 쿠폰 검증 유틸: `UserCouponService.validateCouponUsable`
- 포인트 동시성 테스트: `PointServiceTest.포인트_동시_차감_테스트`
- 텔레그램 폴러: `OnboardingPoller.pollLoop`
- 알림 발송: `AlarmService.notifyMember`

### 9.3 용어 정의
- **쿠폰**: 할인 혜택을 제공하는 프로모션 도구
- **포인트**: 사용자 활동 적립금, 1P = 1원
- **온보딩**: 텔레그램 봇 `/start` 딥링크를 통한 chat_id 등록 과정
- **폴러**: Long Polling 방식으로 텔레그램 API에서 메시지 수신
- **롤백**: 거래 실패 시 원래 상태로 복원

---

**작성자**: MEETLOG 개발팀
**최종 수정일**: 2025-10-10
**버전**: 2.0 (얼음별 대모험)
